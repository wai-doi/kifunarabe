# Research: 駒の捕獲機能

**Feature**: 駒の捕獲機能
**Date**: 2025-11-09
**Status**: 完了

## 概要

将棋の駒の捕獲機能を実装するための技術的調査と意思決定を記録する。既存の駒移動ロジックとターン制御ロジックに統合し、持ち駒の管理と表示を追加する。

## 技術的決定事項

### 1. 持ち駒の状態管理

**決定**: React Hooks (useState) を使用

**理由**:
- 既存のゲーム状態管理(GameState)と一貫性を保つ
- Redux等の外部状態管理ライブラリは不要(憲法のシンプルさ原則)
- ゲーム状態に `capturedPieces` プロパティを追加し、先手と後手の持ち駒を管理

**代替案と却下理由**:
- **Redux/Zustand等の外部ライブラリ**: 過剰な複雑性、現時点でのスケール要件に不要
- **Context API**: 単一コンポーネント階層での使用には過剰、propsバケツリレーで十分

### 2. 持ち駒のデータ構造

**決定**: 駒の種類をキーとするMap構造 `{ [PieceType]: number }`

**理由**:
- 同じ種類の駒の数量を効率的にカウント可能(FR-005)
- 駒の種類ごとの整理が容易(FR-004)
- JavaScriptオブジェクトで簡潔に表現可能

**具体例**:
```typescript
type CapturedPiecesMap = Partial<Record<PieceType, number>>;

interface CapturedPieces {
  sente: CapturedPiecesMap; // 先手の持ち駒
  gote: CapturedPiecesMap;  // 後手の持ち駒
}
```

**代替案と却下理由**:
- **配列構造 `Piece[]`**: 同じ種類の駒をカウントする際に非効率、種類ごとの整理が複雑
- **Set構造**: 数量管理が不便

### 3. 駒の捕獲処理のタイミング

**決定**: 駒の移動処理中に捕獲を統合

**理由**:
- 既存の `updateBoardAfterMove` 関数を拡張
- 移動先に相手の駒があるかを判定し、あれば持ち駒に追加してから駒を移動
- アトミックな操作として実装し、状態の一貫性を保証

**処理フロー**:
1. 移動先のマスに駒があるか確認
2. あれば、その駒の種類と所有者を取得
3. 取った駒を持ち駒に追加(数量を+1)
4. 盤面から相手の駒を削除
5. 移動する駒の位置を更新

**代替案と却下理由**:
- **移動後に別処理で捕獲**: 状態の一貫性リスク、処理の複雑化

### 4. 持ち駒の表示配置

**決定**: 
- 先手の持ち駒: 盤面下部(先手側)
- 後手の持ち駒: 盤面上部(後手側)

**理由**:
- 将棋の実際のゲームと同じ配置で直感的
- 自分の持ち駒が手前に表示され、確認しやすい
- 盤面全体のレイアウトとバランスが良い

**代替案と却下理由**:
- **盤面の左右**: 横幅を圧迫、駒の配置との視覚的関連性が低い
- **モーダル/ポップアップ**: 常時表示が必要な情報には不適切

### 5. 持ち駒の表示形式

**決定**: 駒のアイコン + 数量(2個以上の場合)

**理由**:
- 視覚的に分かりやすい
- 将棋の実際のゲームに近い表現
- Tailwind CSSでシンプルに実装可能

**表示例**:
```
歩 歩 歩    → 歩 ×3
角          → 角
```

**代替案と却下理由**:
- **テキストのみ**: 視認性が低い
- **駒を全て並べる**: 同じ種類が多い場合にスペースを取りすぎる

### 6. 駒移動と捕獲の判定ロジック

**決定**: `captureLogic.ts` に専用の関数を作成

**理由**:
- 責任の分離: 捕獲ロジックを独立したモジュールに
- テストの容易性: 捕獲処理を個別にテスト可能
- 再利用性: 将来の機能拡張(打ち駒など)で再利用可能

**主要関数**:
```typescript
// 移動先に相手の駒があるか判定
function getTargetPiece(pieces: Piece[], position: Position, currentPlayer: Player): Piece | null

// 駒を持ち駒に追加
function addToCapturedPieces(captured: CapturedPieces, piece: Piece, capturingPlayer: Player): CapturedPieces

// 盤面から駒を削除
function removePieceFromBoard(pieces: Piece[], position: Position): Piece[]
```

**代替案と却下理由**:
- **boardState.ts に統合**: ファイルが肥大化、責任が不明確
- **Board.tsx コンポーネントに実装**: ビジネスロジックとUIの分離原則に反する

### 7. テスト戦略

**決定**: 
- ユニットテスト: 捕獲ロジック、持ち駒管理の個別関数
- コンポーネントテスト: CapturedPieces表示、Boardの捕獲動作
- 統合テスト: ShogiBoard全体での駒の捕獲フロー

**理由**:
- TDD原則に従い、実装前にテストを作成
- 仕様書の受け入れ基準から直接テストケースを導出
- 各レイヤーでの責任を明確にテスト

**テストケース例**:
- 駒の捕獲が正しく記録される
- 持ち駒の数量が正確にカウントされる
- 持ち駒が正しく表示される
- ターン制御が捕獲後も正しく機能する

**代替案と却下理由**:
- **E2Eテストのみ**: 低レベルの不具合の特定が困難
- **手動テストのみ**: 回帰テストが非効率、憲法のTDD原則に反する

### 8. パフォーマンス最適化

**決定**: 初期実装では最適化を行わず、必要に応じて後で対応

**理由**:
- 持ち駒の数は最大でも40個程度(歩18枚+その他22枚)
- React Hooksの基本的な状態更新で十分なパフォーマンス
- 早期最適化を避ける(憲法のシンプルさ原則)

**測定指標**:
- 駒の捕獲処理時間: 0.5秒以内(目標)
- 持ち駒表示の更新: 100ms以内(目標)

**将来の最適化候補** (必要に応じて):
- `React.memo` でCapturedPiecesコンポーネントのレンダリング最適化
- `useMemo` で持ち駒の表示リスト生成を最適化

**代替案と却下理由**:
- **初期から最適化**: YAGNI原則に反する、複雑性の増加

## 未解決の懸念事項

なし - 全ての技術的決定事項が明確化され、実装に必要な情報が揃っている。

## 次のステップ

Phase 1: Design & Contracts に進む
- `data-model.md` を作成し、持ち駒のエンティティとゲーム状態の拡張を定義
- `contracts/` にコンポーネントとロジックのインターフェースを記述
- `quickstart.md` を作成し、開発環境のセットアップ手順を記載
