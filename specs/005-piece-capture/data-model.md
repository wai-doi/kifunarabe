# Data Model: 駒の捕獲機能

**Feature**: 駒の捕獲機能
**Date**: 2025-11-09
**Status**: 完了

## 概要

駒の捕獲機能で使用するデータモデルとエンティティを定義する。既存のゲーム状態(GameState)を拡張し、持ち駒(CapturedPieces)の管理を追加する。

## エンティティ定義

### 1. CapturedPiecesMap

駒の種類ごとの数量を管理するマップ構造。

```typescript
/**
 * 持ち駒のマップ構造
 * 駒の種類をキーとし、その数量を値とする
 */
type CapturedPiecesMap = Partial<Record<PieceType, number>>;
```

**プロパティ**:
- キー: `PieceType` (駒の種類: '歩', '香', '桂', '銀', '金', '角', '飛')
- 値: `number` (その種類の持ち駒の数量)

**例**:
```typescript
{
  '歩': 3,
  '角': 1,
  '飛': 1
}
```

**バリデーションルール**:
- 数量は0以上の整数
- 存在しない駒の種類はマップに含めない(undefinedまたはキーなし)
- 王/玉は持ち駒にならない(ゲーム終了条件)

### 2. CapturedPieces

先手と後手それぞれの持ち駒を管理するエンティティ。

```typescript
/**
 * 持ち駒の管理構造
 */
interface CapturedPieces {
  /** 先手の持ち駒 */
  sente: CapturedPiecesMap;
  /** 後手の持ち駒 */
  gote: CapturedPiecesMap;
}
```

**プロパティ**:
- `sente`: 先手(下側プレイヤー)の持ち駒マップ
- `gote`: 後手(上側プレイヤー)の持ち駒マップ

**初期状態**:
```typescript
{
  sente: {},
  gote: {}
}
```

**バリデーションルール**:
- 各プレイヤーの持ち駒マップは独立して管理
- 持ち駒の合計数は盤面から取り除かれた駒の数と一致

### 3. GameState (拡張)

既存のGameStateに持ち駒の情報を追加。

```typescript
/**
 * ゲーム全体の状態(持ち駒対応版)
 */
interface GameState {
  /** 盤上の駒の配列 */
  pieces: Piece[];
  /** 選択中のマスの位置 */
  selectedSquare: Position | null;
  /** 現在のターン */
  currentTurn: Turn;
  /** 持ち駒 (新規追加) */
  capturedPieces: CapturedPieces;
}
```

**新規プロパティ**:
- `capturedPieces`: 先手と後手の持ち駒を管理

**初期状態**:
```typescript
{
  pieces: INITIAL_POSITION,
  selectedSquare: null,
  currentTurn: 'sente',
  capturedPieces: {
    sente: {},
    gote: {}
  }
}
```

### 4. CapturedPiecesProps

持ち駒表示コンポーネントのプロパティ。

```typescript
/**
 * CapturedPiecesコンポーネントのプロパティ
 */
interface CapturedPiecesProps {
  /** 表示する持ち駒のマップ */
  capturedPieces: CapturedPiecesMap;
  /** プレイヤー(表示位置の決定に使用) */
  player: Player;
}
```

**プロパティ**:
- `capturedPieces`: 表示する持ち駒のマップ
- `player`: 先手('sente')または後手('gote')、表示位置を決定

## データフロー

### 駒の捕獲フロー

```
1. ユーザーが駒を移動
   ↓
2. 移動先に相手の駒があるか確認
   ↓
3. 相手の駒がある場合:
   a. 相手の駒の種類と所有者を取得
   b. 持ち駒に追加(capturedPieces更新)
   c. 盤面から相手の駒を削除(pieces更新)
   d. 移動する駒の位置を更新(pieces更新)
   ↓
4. ゲーム状態(GameState)を更新
   ↓
5. 持ち駒表示コンポーネント(CapturedPieces)が再レンダリング
   ↓
6. ターンを交代(currentTurn更新)
```

### 状態更新の不変性

全ての状態更新は不変性(immutability)を保つ:

```typescript
// ❌ 悪い例: 直接変更
state.capturedPieces.sente['歩'] = 3;

// ✅ 良い例: 新しいオブジェクトを作成
setCapturedPieces({
  ...capturedPieces,
  sente: {
    ...capturedPieces.sente,
    '歩': (capturedPieces.sente['歩'] || 0) + 1
  }
});
```

## バリデーションルール

### 持ち駒の整合性

1. **数量の正当性**:
   - 各駒の種類の持ち駒数量は0以上
   - 歩の持ち駒は最大18枚(初期配置数)
   - その他の駒も初期配置数を超えない

2. **駒の種類の制限**:
   - 王/玉は持ち駒にならない
   - 成り駒は持ち駒にならない(将来の拡張で元の駒に戻す)

3. **所有者の一貫性**:
   - 取った駒は取ったプレイヤーの持ち駒になる
   - 駒の所有者情報は保持しない(取られた時点で取ったプレイヤーの駒になる)

### 盤面との整合性

1. **駒の総数**:
   ```
   盤面の駒数 + 先手の持ち駒数 + 後手の持ち駒数 = 初期配置の総駒数
   ```

2. **駒の移動と捕獲**:
   - 移動先に相手の駒がある場合のみ捕獲が発生
   - 自分の駒がある場所には移動できない(既存ルール維持)
   - 空のマスへの移動では捕獲は発生しない

## 状態遷移

### 持ち駒の追加

```
初期状態: { sente: {}, gote: {} }
   ↓
先手が歩を取る
   ↓
状態: { sente: { '歩': 1 }, gote: {} }
   ↓
後手が角を取る
   ↓
状態: { sente: { '歩': 1 }, gote: { '角': 1 } }
   ↓
先手がさらに歩を取る
   ↓
状態: { sente: { '歩': 2 }, gote: { '角': 1 } }
```

### 複数種類の持ち駒

```
初期状態: { sente: {}, gote: {} }
   ↓
先手が歩、香、桂を順に取る
   ↓
状態: { 
  sente: { '歩': 1, '香': 1, '桂': 1 }, 
  gote: {} 
}
```

## パフォーマンス考慮事項

1. **持ち駒の更新**:
   - オブジェクトのシャローコピーで効率的に更新
   - 不要なリレンダリングを避けるため、参照の変更のみで更新を通知

2. **持ち駒の表示**:
   - 駒の種類ごとにグループ化して表示
   - 数量が2個以上の場合のみ数値を表示し、表示要素を削減

3. **メモリ効率**:
   - 存在しない駒の種類はマップに含めない
   - 数量が0になった駒の種類はマップから削除

## 将来の拡張性

以下の機能拡張を考慮した設計:

1. **持ち駒を打つ機能** (別機能として実装予定):
   - 持ち駒から駒を選択して盤面に配置
   - 持ち駒の数量を減らす処理

2. **成り駒の捕獲** (別機能として実装予定):
   - 成り駒を取ったときに元の駒に戻す処理
   - 持ち駒に追加する際に駒の種類を変換

3. **駒の捕獲履歴**:
   - 取った駒の順序を記録
   - 巻き戻し機能のサポート

4. **永続化**:
   - LocalStorageへの保存
   - サーバーへの同期
