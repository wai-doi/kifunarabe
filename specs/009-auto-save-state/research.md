# Research: 状態の自動保存

**Feature**: 009-auto-save-state
**Date**: 2025-12-09
**Phase**: 0 - Outline & Research

## 調査項目

### 1. localStorage使用のベストプラクティス

**決定事項**: ブラウザ標準のlocalStorageを使用して状態を永続化する

**選択理由**:
- ブラウザ標準APIで追加の依存関係が不要
- 同期的なAPIで実装がシンプル
- 5-10MBの容量制限で将棋の状態を保存するには十分
- すべてのモダンブラウザで対応済み
- オフラインでも動作する

**検討した代替案**:
- **IndexedDB**: 非同期API、より大きな容量、複雑性が増す → 現時点では過剰
- **sessionStorage**: ブラウザを閉じると消える → 要件を満たさない
- **Cookie**: 容量制限が小さい（4KB）、サーバーに送信される → 不適切
- **サーバー側ストレージ**: バックエンドが必要、オフライン動作不可 → スコープ外

**実装の考慮事項**:
- JSON.stringify/parseでシリアライズ・デシリアライズ
- エラーハンドリング（容量超過、パース失敗）
- ストレージキーの命名規則（例: `kifunarabe:gameState`）

### 2. React での自動保存パターン

**決定事項**: useEffect フックで状態変更を監視し、依存配列で自動保存をトリガーする

**選択理由**:
- React標準のパターンで追加ライブラリ不要
- 依存配列による細かい制御が可能
- デバウンス/スロットルの追加も容易
- テストが容易（モック可能）

**実装パターン**:
```typescript
useEffect(() => {
  // 状態が変更されたら自動保存
  saveToLocalStorage({ board, capturedPieces, currentTurn, history, currentIndex });
}, [board, capturedPieces, currentTurn, history, currentIndex]);
```

**検討した代替案**:
- **カスタムフック（usePersistence）**: より再利用可能だが、現時点では単一コンポーネントのみ → 必要になってからリファクタリング
- **状態管理ライブラリ（Redux Persist等）**: 大規模な状態管理には有用だが、現在の規模では過剰 → YAGNI原則に反する
- **手動保存API呼び出し**: 各状態更新後に明示的に呼び出す → ヒューマンエラーのリスク、保守性低下

**パフォーマンス考慮事項**:
- 頻繁な保存による性能問題を避けるため、必要に応じてデバウンス（例: 100ms）を追加
- 初回マウント時の保存をスキップ（初期化と保存の区別）

### 3. 状態のシリアライゼーション戦略

**決定事項**: 既存の型定義をそのままJSON化し、復元時に型安全性を検証する

**選択理由**:
- 既存の型定義（Board, CapturedPieces, Turn, History）がそのままJSON化可能
- TypeScriptの型システムでコンパイル時チェック
- 復元時のバリデーションで実行時の型安全性を保証

**データ構造**:
```typescript
interface PersistedGameState {
  board: Board;
  capturedPieces: CapturedPieces;
  currentTurn: Turn;
  history: MoveHistoryEntry[];
  currentIndex: number;
  version: string; // 将来の互換性のため
  timestamp: number; // デバッグ用
}
```

**検討した代替案**:
- **カスタムシリアライゼーション形式**: より効率的だが複雑性が増す → 現時点では不要
- **圧縮**: データサイズを減らせるが、パフォーマンスオーバーヘッド → 容量制限に余裕があるため不要
- **差分保存**: 履歴の効率的な保存だが、実装が複雑 → 将来の最適化として検討

**バリデーション戦略**:
- 復元時に型チェック（typeof, Array.isArray等）
- 必須フィールドの存在確認
- 不正なデータの場合は初期配置にフォールバック
- バージョン番号による将来の互換性対応

### 4. エラーハンドリングとフォールバック

**決定事項**: try-catchで例外をキャッチし、エラー時は初期配置にフォールバック、コンソールに警告を出力

**選択理由**:
- ユーザー体験を損なわない（エラーでもアプリは動作）
- 開発者にデバッグ情報を提供
- 仕様書の要件（FR-008）を満たす

**エラーケースと対応**:
| エラーケース | 対応 | ユーザーへの影響 |
|------------|------|----------------|
| localStorage無効化 | 保存をスキップ、セッション内は動作 | 再起動時に状態が失われる |
| 容量超過（QuotaExceededError） | 保存失敗、セッション内は動作 | 再起動時に状態が失われる |
| パースエラー（JSON不正） | 初期配置を復元 | 保存データが失われる |
| 型不一致（バリデーション失敗） | 初期配置を復元 | 保存データが失われる |
| localStorage未対応ブラウザ | 保存・復元をスキップ | 通常の動作（保存なし） |

**実装方針**:
- エラーは握りつぶさず、console.warnで記録
- ユーザーには通知せず、シームレスに動作を継続
- 開発環境では詳細なエラー情報を出力

### 5. 既存の履歴管理機能との統合

**決定事項**: 既存のhistoryManager.tsを拡張し、履歴情報（history配列とcurrentIndex）も保存・復元の対象に含める

**選択理由**:
- 仕様書の要件（FR-004, FR-009）を満たす
- User Story 3の実現に不可欠
- 既存のデータ構造を変更せず、保存対象を追加するのみ

**統合ポイント**:
- `ShogiBoard.tsx`で管理している`history`と`currentIndex`をlocalStorageに保存
- 復元時は履歴全体と現在位置を復元
- ナビゲーション操作（前へ/次へ）の結果も自動保存

**既存機能への影響**:
- historyManager.tsの変更は不要（読み取り専用の使用）
- ShogiBoard.tsxのuseStateで管理している状態に保存ロジックを追加
- NavigationControls.tsxの変更は不要（イベントハンドラは既存のまま）

### 6. テスト戦略

**決定事項**: ユニットテストと統合テストの2層構造

**ユニットテスト（persistenceManager.test.ts）**:
- localStorageのモック
- 保存・復元の基本動作
- エラーハンドリング（容量超過、パース失敗等）
- バリデーションロジック

**統合テスト（ShogiBoard.test.tsx）**:
- コンポーネントマウント時の状態復元
- 駒移動後の自動保存
- ブラウザ再起動のシミュレーション（アンマウント→再マウント）
- 履歴ナビゲーション後の保存・復元

**テストツール**:
- Vitest: テストランナー
- React Testing Library: コンポーネントテスト
- vi.mock: localStorageのモック

**カバレッジ目標**:
- persistenceManager.ts: 100%（クリティカルなロジック）
- ShogiBoard.tsx統合部分: 主要シナリオのカバー

## 技術的リスクと対策

| リスク | 影響 | 対策 |
|-------|------|------|
| localStorage容量超過 | 保存失敗 | エラーハンドリングで通常動作を継続、ユーザーには影響なし |
| ブラウザ互換性 | 古いブラウザで動作しない | 機能検出でグレースフルデグラデーション |
| 保存頻度によるパフォーマンス低下 | UI の反応速度低下 | デバウンス導入（必要に応じて） |
| データ構造の将来的な変更 | 後方互換性の問題 | バージョン番号でマイグレーション対応 |

## 実装の優先順位

**P1（MVP）**:
1. persistenceManager.tsの作成（保存・復元・バリデーション）
2. ShogiBoard.tsxへの統合（useEffect追加）
3. 基本的なエラーハンドリング

**P2（品質向上）**:
1. 包括的なテストスイート
2. 詳細なエラーロギング
3. パフォーマンス最適化（必要に応じてデバウンス）

**P3（将来の拡張）**:
1. データマイグレーション機能
2. 複数の保存スロット対応
3. エクスポート/インポート機能

## まとめ

この機能は既存の技術スタック（TypeScript + React + localStorage）のみで実装可能であり、新規の依存関係は不要です。シンプルな設計により、実装リスクは低く、テストも容易です。既存のコードベースへの影響も最小限（新規ファイル2つ、既存ファイル1つの修正）で済みます。
